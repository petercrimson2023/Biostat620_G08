```{r}
df <- xinweiw_baseline_data
```

```{r}

library(dplyr)
library(psych)


# 连续变量
continuous_vars <- df %>% select(Social.ST.min, Social.Time.Ratio, Pickups, Devices)
continuous_stats <- describe(continuous_vars)

# 二元变量
categorical_vars <- df %>% select(Stay.late, Sex) 
categorical_stats <- sapply(categorical_vars, function(x) list(table(x)))

continuous_stats
categorical_stats

```

```{r}

hist(df$Social.ST.min, main="Histogram of Social Media Screen Time", xlab="Minutes per day")
hist(df$ Social.Time.Ratio, main="Histogram of Social Time Ratio", xlab="Minutes per day")
hist(df$ Social.Time.Ratio, main="Histogram of Pickups", xlab="times per day")



boxplot(df$Social.ST.min, main="Boxplot of Social Media Screen Time", ylab="Minutes per day")

```


```{r}
#Stay.late 二元变量
barplot(table(df$Stay.late), main="Barplot of Phone Pickups after Midnight", xlab="Pickup Time", ylab="Count")

```


```{r}
library(ggplot2)
ggplot(df, aes(factor(Stay.late), Social.ST.min)) + geom_violin(trim=FALSE)

# 分组箱线图
ggplot(df, aes(factor(Stay.late), Social.ST.min)) + geom_boxplot()

#在您的小提琴图中，Stay.late为0的组的数据分布看起来更加集中，而Stay.late为1的组则数据分布更广，但由于样本量可能很小（小提琴图较平），不容易看出明显的分布趋势。另外，由于0组的小提琴图比1组宽，这暗示了0组的数据点更多，这是有意义的，因为大多数人晚上不会拿起手机，即Stay.late大多数情况应该为0。
```

```{r}
library(dplyr)
library(ggplot2)

# Grouping the data by 'Sex' and calculating the mean of 'Social.ST.min'
polar_data <- df %>%
  group_by(Stay.late) %>%
  summarise(Value = mean(Social.ST.min, na.rm = TRUE)) %>%
  mutate(Category = if_else(Stay.late == 0, "normal", "Staylate"))

# Now, polar_data should have 'Category' and 'Value' columns
# You can plot it using ggplot2

ggplot(polar_data, aes(x = Category, y = Value, fill = Category)) +
  geom_bar(stat = "identity") +
  coord_polar() +
  theme_void() +
  labs(title = "Polar Area Diagram of Social Screen Time by Stay up late")

```

```{r}
library(dplyr)
library(lubridate)
library(ggplot2)

# 假设您的数据框架叫做df，并且有一个日期列名为Date

# 首先，将日期字符串转换为日期对象
df$Date <- as.Date(df$Date, format = "%m/%d/%Y")

# 然后，创建一个新列来表示每个日期所在的周
df$Week <- week(df$Date)

# 现在，按周分组并计算每周的Social.ST.min的平均值
weekly_data <- df %>%
  group_by(Week) %>%
  summarise(Average_ST_min = mean(Social.ST.min, na.rm = TRUE)) %>%
  mutate(Category = as.factor(Week))  

ggplot(weekly_data, aes(x = Category, y = Average_ST_min, fill = Category)) +
  geom_bar(stat = "identity") +
  coord_polar() +
  theme_void() +
  labs(title = "极区图：每周社交媒体使用时间平均值")

```





























